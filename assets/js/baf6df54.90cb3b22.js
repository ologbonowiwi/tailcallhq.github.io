"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5612],{3262:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var s=t(5893),i=t(1151);const a={title:"Sequencing & Parallelism",description:"Tailcall revolutionizes data access layer development by automating the orchestration of API calls, enabling optimal execution strategies for both sequencing and parallelism."},r=void 0,l={id:"guides/execution-strategy",title:"Sequencing & Parallelism",description:"Tailcall revolutionizes data access layer development by automating the orchestration of API calls, enabling optimal execution strategies for both sequencing and parallelism.",source:"@site/docs/guides/execution-strategy.md",sourceDirName:"guides",slug:"/guides/execution-strategy",permalink:"/docs/guides/execution-strategy",draft:!1,unlisted:!1,editUrl:"https://github.com/tailcallhq/tailcallhq.github.io/tree/develop/docs/guides/execution-strategy.md",tags:[],version:"current",frontMatter:{title:"Sequencing & Parallelism",description:"Tailcall revolutionizes data access layer development by automating the orchestration of API calls, enabling optimal execution strategies for both sequencing and parallelism."},sidebar:"tutorialSidebar",previous:{title:"Environment Variables",permalink:"/docs/guides/environment-variables"},next:{title:"GraphQL on gRPC",permalink:"/docs/guides/grpc"}},o={},c=[{value:"Examples",id:"examples",level:2},{value:"Example 1: Fetching a Specific User and Their Posts",id:"example-1-fetching-a-specific-user-and-their-posts",level:3},{value:"Example 2: Searching Multiple Posts and Users by ID",id:"example-2-searching-multiple-posts-and-users-by-id",level:3},{value:"Example 3: Fetching Posts with Users",id:"example-3-fetching-posts-with-users",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Building data access layers often involves meticulous orchestration of API calls, but Tailcall simplifies this process. By analyzing your defined schema, it automatically determines the optimal execution strategy, deciding when to sequence calls and when to run them in parallel. This allows you to focus on your core application logic, while Tailcall handles the optimization seamlessly. Now, let's get into some real-world examples to illustrate its functionality."}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.h3,{id:"example-1-fetching-a-specific-user-and-their-posts",children:"Example 1: Fetching a Specific User and Their Posts"}),"\n",(0,s.jsx)(n.p,{children:"Imagine you're building a blog and want to display a specific user's profile page containing their information and all their posts."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Schema:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'type Query {\n  # Retrieve a specific user by ID\n  user(id: Int!): User @http(path: "/users/{{value.id}}")\n}\n\ntype User {\n  id: Int!\n  name: String!\n  username: String!\n  email: String!\n\n  # Access user\'s posts using their ID in the path\n  posts: [Post] @http(path: "/users/{{value.id}}/posts")\n}\n\ntype Post {\n  id: Int!\n  title: String!\n  body: String!\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"GraphQL Query:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query getUserAndPosts($userId: Int!) {\n  # Fetch the user by ID\n  user(id: $userId) {\n    id\n    name\n    username\n    email\n    # Sequentially retrieve all posts for the fetched user\n    posts {\n      id\n      title\n      body\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Tailcall understands that retrieving the user's posts depends on knowing the user's ID, which is obtained in the first step. Therefore, it automatically fetches the user first and then uses their ID to retrieve all their posts in a sequential manner."}),"\n",(0,s.jsx)(n.h3,{id:"example-2-searching-multiple-posts-and-users-by-id",children:"Example 2: Searching Multiple Posts and Users by ID"}),"\n",(0,s.jsx)(n.p,{children:"Suppose you're building a social media platform and want to display profiles of specific users and their recent posts."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Schema:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'type Query {\n  # Retrieve users from the "/users" endpoint\n  users: [User] @http(path: "/users")\n}\n\ntype User {\n  id: Int!\n  name: String!\n  username: String!\n  email: String!\n\n  # Access user\'s posts using their ID in the path\n  posts: [Post] @http(path: "/users/{{value.id}}/posts")\n}\n\ntype Post {\n  id: Int!\n  title: String!\n  body: String!\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"GraphQL Query:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query getUsersWithLatestPosts {\n  # Retrieve all users\n  users {\n    id\n    name\n    username\n    email\n    # Access user's posts through the nested field\n    posts {\n      id\n      title\n      body\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This query retrieves details of multiple users and their most recent posts based on the provided user IDs. Tailcall recognizes that fetching user details and their individual posts are independent tasks. As a result, it can execute these requests concurrently for each user."}),"\n",(0,s.jsx)(n.h3,{id:"example-3-fetching-posts-with-users",children:"Example 3: Fetching Posts with Users"}),"\n",(0,s.jsx)(n.p,{children:"Imagine you're building a social media platform and want to display a list of posts with each post's author. Traditionally, you might write a query that retrieves all posts and then, for each post, make a separate request to fetch its corresponding user. This approach leads to the N+1 problem, where N represents the number of posts, and 1 represents the additional request per post to retrieve its user."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Schema:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:'type Query {\n  posts: [Post] @http(path: "/posts")\n}\n\ntype Post {\n  id: Int!\n  userId: Int!\n  title: String!\n  body: String!\n  user: User @http(path: "/users/{{value.userId}}")\n}\n\ntype User {\n  id: Int!\n  name: String!\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"GraphQL Query:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query getPostsWithUsers {\n  posts {\n    id\n    userId\n    title\n    body\n    user {\n      id\n      name\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Tailcall analyzes the schema and recognizes that fetching user details for each post is independent. It can potentially execute these requests to ",(0,s.jsx)(n.code,{children:"/users/{{value.userId}}"})," concurrently, fetching user data for multiple posts simultaneously."]}),"\n",(0,s.jsx)(n.p,{children:"In summary, Tailcall automates the management of sequence and parallelism in API calls. It analyzes the defined schema to optimize execution, freeing developers from manual intervention."})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>r});var s=t(7294);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);